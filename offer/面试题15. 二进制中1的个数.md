# 面试题15. 二进制中1的个数

请实现一个函数，输入一个整数，输出该数二进制表示中 1 的个数。例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2。

示例 1：

输入：00000000000000000000000000001011
输出：3
解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。
示例 2：

输入：00000000000000000000000010000000
输出：1
解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 '1'。
示例 3：

输入：11111111111111111111111111111101
输出：31
解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 '1'。


注意：本题与主站 191 题相同：https://leetcode-cn.com/problems/number-of-1-bits/



## 解法一

`n & 1` 做与运算，1 除了最低位都是 0，可以检查最后一位是 0 还是 1，检查完毕后右移一位，继续检查最低位，直到 `n = 0` 检查结束。

时间复杂度与二进制 n 的位数有关，uint32_t 的范围下运行时间可以忽略不计，空间复杂度 O(1)



```c++
class Solution {
public:
    int hammingWeight(uint32_t n) {
        int cnt = 0, flag = 1;
        while(n) {
            if(n & flag)  ++cnt;
            n = n >> 1;
        }
        return cnt;
    }
};
```



执行用时 :0 ms, 在所有 C++ 提交中击败了100.00%的用户

内存消耗 :5.8 MB, 在所有 C++ 提交中击败了100.00%的用户



## 解法二

 `n & (n-1)` 进行与运算可以清除最低位的1，因为从二进制的角度讲，n 相当于在 n - 1 的最低位加上 1。举个例子，8（1000）= 7（0111）+ 1（0001），所以 8 & 7 = （1000）&（0111）= 0（0000），清除了 8 最右边的 1（其实就是最高位的 1，因为8的二进制中只有一个 1）。再比如7（0111）= 6（0110）+ 1（0001），所以 7 & 6 = （0111）&（0110）= 6（0110），清除了 7 的二进制表示中最右边的 1（也就是最低位的 1）。

每次把 n 更新为与运算的结果 ` n = n & (n-1)` ，直到 `n = 0` ；循环的次数表示清除 1 的次数，也就是二进制中 1 的个数；相比解法一循环次数明显减少，只由二进制中 1 的个数决定。

时间复杂度 O(1)，空间复杂度 O(1)

```c++
class Solution {
public:
    int hammingWeight(uint32_t n) {
        int cnt = 0;
        while(n) {
            n = n & (n-1);
            ++cnt;
        }
        return cnt;
    }
};
```



执行用时 :0 ms, 在所有 C++ 提交中击败了100.00%的用户

内存消耗 :6 MB, 在所有 C++ 提交中击败了100.00%的用户