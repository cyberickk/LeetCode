# 面试题04. 二维数组中的查找

在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。

 

示例:

现有矩阵 matrix 如下：

[
  [1,   4,  7, 11, 15],
  [2,   5,  8, 12, 19],
  [3,   6,  9, 16, 22],
  [10, 13, 14, 17, 24],
  [18, 21, 23, 26, 30]
]
给定 target = 5，返回 true。

给定 target = 20，返回 false。

 

限制：

0 <= n <= 1000

0 <= m <= 1000

 

注意：本题与主站 240 题相同：https://leetcode-cn.com/problems/search-a-2d-matrix-ii/



因为二维数组已经行、列有序，所以采用类似二分查找的思想，选取中间值（左下角或者右上角）为基准进行比较。以左下角为例：

- 当该元素比查找元素大时，该元素已经是所在行中最小的元素，这一行都不会存在目标值，行号减一继续查找；
- 当该元素比查找元素小时，该元素已经是所在列的最大元素，这一列都不会存在目标值，列号加一继续查找；
- 退出循环的条件是走到边界，行号减小到 0 或者列号增加到最大值

注意获取二维数组的行数是 `matrix.size()` ，列数是 `matrix[0].size()` ，如果要用最大下标则应该减一；先对二维数组进行判空，为空时直接返回 false，不判空则碰到空的测试用例会报错。

分析时间复杂度，因为每次循环后仅在列或者行方向前进一次，最坏情况下从左下角走到右上角共需要行数+列数次，时间复杂度 O(m+n)，空间复杂度 O(1)



```c++
class Solution {
public:
    bool findNumberIn2DArray(vector<vector<int>>& matrix, int target) {
        if(matrix.size() == 0 || matrix[0].size() == 0) return false;
        int i = matrix.size() - 1, width = matrix[0].size() - 1, j = 0;
        while(i >= 0 && j <= width) {
            if(matrix[i][j] == target) return true;
            else if(matrix[i][j] > target) --i;
            else ++j;
        }
        return false;
    }
};
```



执行用时 :48 ms, 在所有 C++ 提交中击败了74.33%的用户

内存消耗 :13 MB, 在所有 C++ 提交中击败了100.00%的用户